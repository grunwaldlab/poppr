\documentclass[letterpaper]{article}
%\VignetteIndexEntry{Data import and manipulation}
%\VignetteEngine{knitr::knitr}
\setcounter{tocdepth}{2}
\usepackage{graphicx}
\usepackage[colorlinks = true,
            urlcolor = blue,
            citecolor = blue,
            linkcolor = blue]{hyperref}
\usepackage{array}
\usepackage{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage[utf8]{inputenc} % for UTF-8/single quotes from sQuote()
\usepackage{fullpage}
\usepackage{mathtools}
\usepackage{makeidx}
\usepackage{longtable}
\usepackage{natbib}

% for bold symbols in mathmode
\usepackage{bm}
\newcommand{\R}{\mathbb{R}}
\newcommand{\m}[1]{\mathbf{#1}}
\newcommand{\tab}{\hspace*{1em}}
\newcolumntype{H}{>{\setbox0=\hbox\bgroup} c<{\egroup}@{}}
\newcommand{\cmdlink}[2]{%
  \texttt{\hyperref[#1]{#2}}%
}
\newcommand{\seclink}[2]{%
  \textsc{\hyperref[#1]{#2}}%
}

\newcommand{\poppr}{\textit{poppr}}
\newcommand{\Poppr}{\textit{Poppr}}
\newcommand{\adegenet}{\textit{adegenet}}
\newcommand{\Adegenet}{\textit{Adegenet}}
\newcommand{\tline}{
  \noindent
  \rule{\textwidth}{1pt}
  \par
}
\newcommand{\bline}{
  \noindent
  \rule{\textwidth}{1pt}
  \kern1pt
}

\newcommand{\jala}{
  \includegraphics[height = 5mm, keepaspectratio=true]{jalapeno-poppers}
}

\newcommand{\revjala}{
  \scalebox{-1}[1]{\jala{}}
}

\title{Data import and manipulation in poppr version \Sexpr{packageVersion("poppr")}}
\author{Zhian N. Kamvar$^{1}$\ and Niklaus J. Gr\"unwald$^{1,2}$\\\scriptsize{1)
Department of Botany and Plant Pathology, Oregon State University, Corvallis,
OR}\\\scriptsize{2) Horticultural Crops Research Laboratory, USDA-ARS,
Corvallis, OR}}

\begin{document}


<<echo=FALSE, warning=FALSE>>=
knitr::opts_knit$set(out.format = "latex")
thm <- knitr::knit_theme$get("acid")
knitr::knit_theme$set(thm)
knitr::opts_chunk$set(concordance=TRUE)
knitr::opts_chunk$set(size = 'small', message = FALSE, warning = FALSE)
knitr::opts_chunk$set(out.width = '0.5\\linewidth', fig.align = "center", fig.show = 'asis')
@

<<poppr_funk, eval = TRUE, echo = FALSE>>=
print_command <- function(funk){
  fargs <- formals(funk)

  lapply(names(fargs), function(arg_name, fargs){
    arg <- fargs[[arg_name]]
    if (missing(arg)){
      fargs[[arg_name]] <<- as.symbol(arg_name)
      names(fargs)[names(fargs) == arg_name] <<- ""
    }
  }, fargs)
  fargs$call <- as.symbol(funk)
  fargs <- fargs[c(length(fargs), 1:(length(fargs) - 1))]
  return(as.call(fargs))
}
@

\definecolor{light-gray}{gray}{0.97}
\definecolor{salmon}{HTML}{F0AAAA}

\maketitle
\begin{abstract}
\Poppr{} provides open-source, cross-platform tools for quick analysis of
population genetic data enabling focus on data analysis and interpretation.
While there are a plethora of packages for population genetic analysis, few are
able to offer quick and easy analysis of populations with mixed reproductive
modes. \Poppr{}'s main advantage is the ease of use and integration with other
packages such as \adegenet{} and \textit{vegan}, including support for novel
methods such as clone correction, multilocus genotype analysis, calculation of
Bruvo's distance, and the index of association. New features in version 2.0
include generation of minimum spanning networks with reticulation, calculation
of the index of association for genomic data, and filtering multilocus genotypes
based on genetic distance.
\end{abstract}
% Inserting the \Poppr{} logo here

\begin{figure}[b]
  \centering
  \label{logo}
  \includegraphics{popprlogo}
\end{figure}

\newpage
% Set the width of figures.
\setkeys{Gin}{width=0.5\textwidth}
\begingroup
  \hypersetup{linkcolor=black}
  \tableofcontents
\endgroup

%\linenumbers

%=============================================================================%
%=============================================================================%
%
%
%
%=============================================================================%
%=============================================================================%
\newpage
\renewcommand\thesection{\roman{section}}
\section{Table of Functions}%\addcontentsline{toc}{section}{Table of Functions}
\renewcommand\thesection{\arabic{section}}
\setcounter{section}{0}
\label{table:funk}

\tab\tab Below is a table of functions found in \poppr{}. These functions are
linked within the document. If a function name is blue, simply click on it to go
to its definition and description.

\begin{center}
\begin{longtable}{ll}
\caption{Functions available in \poppr{}} \label{function_table} \\

\hline \\[-1.5ex] \textbf{\large Function} & \textbf{\large Description} \\ \hline \\[-1.5ex]
\endfirsthead

\multicolumn{2}{c}%
{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
\hline \\[-1.5ex] \textbf{\large Function} & \textbf{\large Description} \\ \hline \\[-1.5ex]
\endhead

\hline \multicolumn{2}{r}{\textbf{Continued on next page...}} \\
\endfoot

\hline \hline
\endlastfoot

\multicolumn{2}{l}{\Large\textsc{Import/Export}}\\
\texttt{getfile} & Provides a quick GUI to grab files for import \\
\cmdlink{intro:import:read.genalex}{read.genalex} & Read \textit{GenAlEx} formatted csv files to a \texttt{genind} object \\
\cmdlink{intro:import:genind2genalex}{genind2genalex} & Converts \texttt{genind} objects to \textit{GenAlEx} formatted csv files \\
\cmdlink{intro:genclone:as.genclone}{as.genclone} & Converts \texttt{genind} objects to \texttt{genclone} objects \\
%----------------|
\hline \\[-1.5ex]
\multicolumn{2}{l}{\Large\textsc{Manipulation}}\\
\cmdlink{intro:genclone:as.genclone}{as.genclone} & Converts \texttt{genind} objects to \texttt{genclone} objects \\
\cmdlink{function:genclone2genind}{genclone2genind} & Removes the \texttt{@mlg} slot from \texttt{genclone} objects \\
\texttt{setPop} & \textit{(moved to adegenet)} Set the population using defined hierarchies\\
\texttt{splitStrata} & \textit{(moved to adegenet)} Split a concatenated hierarchy imported as a population\\
\texttt{strata} & \textit{(moved to adegenet)} Define a population hierarchy of a \texttt{genclone} object\\
\texttt{strata} & \textit{(moved to adegenet)} Extract the hierarchy data frame\\
\texttt{addStrata} & \textit{(moved to adegenet)} Add a vector or data frame to an existing hierarchy \\
\texttt{nameStrata} & \textit{(moved to adegenet)} Rename a population hierarchy\\
\cmdlink{data.manip:missing:missingno}{missingno} & Handles missing data \\
\cmdlink{data.manip:cc:clonecorrect}{clonecorrect} & Clone censors at a specified population hierarchy \\
\cmdlink{data.manip:informloci}{informloci} & Detects and removes phylogenetically uninformative loci \\
\cmdlink{data.manip:divide:popsub}{popsub} & Subsets \texttt{genind} objects by population \\
\cmdlink{data.manip:shuffle:shufflepop}{shufflepop} & Shuffles genotypes at each locus using four different shuffling algorithms \\
\cmdlink{intro:import:polyploid}{recode\_polyploids} &  recode polyploid data sets with missing alleles imported as ``0''\\
\texttt{fix\_replen} & Finds and fixes inconsistant repeat lengths for Bruvo's distance.\\
%----------------|
\hline \\[-1.5ex]
\multicolumn{2}{l}{\Large\textsc{Distances}}\\
\texttt{bruvo.dist} & Bruvo's distance \\
\texttt{diss.dist} & Absolute genetic distance (see \texttt{provesti.dist}) \\
\texttt{nei.dist} & Nei's 1978 genetic distance \\
\texttt{rogers.dist} & Rogers' euclidean distance \\
\texttt{reynolds.dist} & Reynolds' coancestry distance \\
\texttt{edwards.dist} & Edwards' angular distance \\
\texttt{provesti.dist} & Provesti's absolute genetic distance \\
%----------------|
\hline \\[-1.5ex]
\multicolumn{2}{l}{\Large\textsc{Bootstrapping}}\\
\texttt{aboot} & Creates a bootstrapped dendrogram for any distance measure \\
\texttt{bruvo.boot} & Produces dendrograms with bootstrap support\\
 & based on Bruvo's distance \\
\texttt{diversity\_boot} & Generates boostrap distributions of diversity \\
 & statistics for multilocus genotypes \\
\texttt{diversity\_ci} & Generates confidence intervals for \\
 & multilocus genotype diversity \\
%----------------|
\hline \\[-1.5ex]
\multicolumn{2}{l}{\Large\textsc{Analysis: Multilocus Genotypes}}\\
\texttt{mlg} & Calculates the number of multilocus genotypes \\
\texttt{mll} & Displays the current multilocus lineages (genotypes) defined. \\
\texttt{nmll} & Same as \texttt{mlg}. \\
\cmdlink{mlg:cross:mlg.crosspop}{mlg.crosspop} & Finds all multilocus genotypes that cross populations \\
\cmdlink{mlg:table:mlg.table}{mlg.table} & Returns a table of populations by multilocus genotypes \\
\cmdlink{mlg:mix:mlg.vector}{mlg.vector} & Returns a vector of a numeric multilocus genotype assignment for each individual \\
\texttt{mlg.id} & Finds all individuals associated with a single multilocus genotype \\
\texttt{mlg.filter} & Collapses MLGs by genetic distance \\
\texttt{filter\_stats} & Calculate mlg.filter for all algorithms and plot \\
\texttt{cutoff\_predictor} & predict cutoff threshold from mlg.filter.  \\
\texttt{mll.custom} & Allows for the custom definition of multilocus lineages \\
\texttt{mll.levels} & Allows the user to change levels of custom MLLs.  \\
\texttt{diversity\_stats} & Creates a table of diversity indices for multilocus genotypes.  \\
%----------------|
\hline \\[-1.5ex]
\multicolumn{2}{l}{\Large\textsc{Analysis: Other}}\\
\texttt{poppr.amova} & Analysis of Molecular Variance (as implemented in ade4) \\
\texttt{ia} & Calculates the index of association \\
\texttt{pair.ia} & Calculates the index of association for all loci pairs. \\
\texttt{win.ia} & Index of association windows for genlight objects. \\
\texttt{samp.ia} & Index of association on random subsets of loci for genlight objects. \\
\texttt{poppr} & Returns a diversity table by population \\
\texttt{poppr.all} & Returns a diversity table by population for all compatible \\
 & files specified \\
\texttt{private\_alleles} & Tabulates the occurrences of alleles that only occur \\
 & in one population. \\
\texttt{locus\_table} & Creates a table of summary statistics per locus. \\
%----------------|
\hline \\[-1.5ex]
\multicolumn{2}{l}{\Large\textsc{Visualization}}\\
\texttt{imsn} & interactive construction and visualization of minimum spanning networks \\
\texttt{plot\_poppr\_msn} & Plots minimum spanning networks produced in poppr with\\
 & scale bar and legend \\
\texttt{greycurve} & Helper to determine the appropriate parameters for adjusting the\\
 & grey level for msn functions \\
\texttt{bruvo.msn} & Produces minimum spanning networks based off Bruvo's distance\\
 & colored by population \\
\texttt{poppr.msn} & Produces a minimum spanning network for any pairwise distance\\
 & matrix related to the data \\
\texttt{info\_table} & Creates a heatmap representing missing data or observed ploidy\\
\texttt{genotype\_curve} & Creates a series of boxplots demonstrating how many loci are\\
 & needed to represent the diversity of your data.\\
%----------------|
\hline \\[-1.5ex]
\multicolumn{2}{l}{\Large\textsc{Data Sets}}\\
\texttt{Aeut} & (AFLP) Oomycete root rot pathogen \textit{Aphanomyces euteiches}\\
 & \citep{Grunwald:2006} \\
\texttt{monpop} & (SSR) Peach brown rot pathogen \textit{Monilinia fructicola}\\
 & \citep{everhart2014finescale} \\
\texttt{partial\_clone} & (SSR) partially-clonal data simulated via simuPOP\\
 & \citep{peng2008forward} \\
\texttt{Pinf} & (SSR) Potato late blight pathogen \textit{Phytophthora infestans}\\
 & \citep{goss2014irish} \\
\texttt{Pram} & (SSR) Sudden Oak Death pathogen \textit{Phytophthora ramorum}\\
 & \citep{kamvar2015spatial, goss2009population} \\
\hline

\end{longtable}
\end{center}

\section{Introduction}
\label{intro}

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Purpose}
\label{intro:purpose}

\Poppr{} is an R package with convenient functions for analysis of
genetic data with mixed modes of reproduction including sexual and clonal
reproduction. While there are many R packages in CRAN and other repositories
with tools for population genetic analyses, few are appropriate for populations
with mixed modes of reproduction. There are several stand-alone programs that
can handle these types of data sets, but they are often platform specific and
often only accept specific data types. Furthermore, a typical analysis often
involves switching between many programs, and converting data to each specific
format.

\Poppr{} is designed to make analysis of populations with mixed reproductive
modes more streamlined and user friendly so that the researcher using it can
focus on data analysis and interpretation. \Poppr{} allows analysis of haploid
and diploid dominant/co-dominant marker data including microsatellites, Single
Nucleotide Polymorphisms (SNP), and Amplified Fragment Length Polymorphisms
(AFLP). To avoid creating yet another file format that is specific to a program,
\poppr{} was created on the backbone of the popular R package \adegenet{} and
can take all the file formats that \adegenet{} can take (Genpop, Genetix, Fstat,
and Structure) and newly introduces compatibility with GenAlEx formatted files
(exported to CSV). This means that anything you can analyze in \adegenet{} can
be further analyzed with \poppr{}.

The real power of \poppr{} is in the data manipulation and analytic tools.
\Poppr{} has the ability to bootstrap, clone-censor, and subset data sets. With
\poppr{} you can also quickly calculate Bruvo's distance, the index of
association, and easily determine which multilocus genotypes are shared across
populations.

In version 2.0, tools for genomic data were introduced \citep{kamvar2015novel}.
These tools allow researchers to define what it means to be a clone lost in a
sea of genomic data, generate bootstrapped dendrograms with any genetic
distance, and calculate minimum spanning networks with reticulations to reveal
the underlying population structure of your clonal data.

\subsection{A note about poppr version \Sexpr{packageVersion("poppr")}}

In \poppr{} version 1.1, the \texttt{genclone} object was introduced. This was
an extension of \adegenet{}'s \texttt{genind} object by adding two new slots:

\begin{enumerate}
\item \textbf{mlg} numeric classification of multilocus genotypes in the data set
\item \textbf{hierarchy} storage of multiple population factors.
\end{enumerate}

In particular, the \textbf{hierarchy} slot played a large role in providing a
more tractable way of performing analyses such as clone-correction and AMOVA. In
March of 2015, The \textbf{hierarchy} slot was ported to the \adegenet{}
packaged and the name was changed to the \textbf{strata} slot. This means that
code written before \poppr{} 2.0.0 might need some small changes. Please see the
\textsc{Migrating from poppr version 1} vignette for more details:

<<migration_vignette, eval = FALSE>>=
vignette("how_to_migrate", package = "poppr")
@

\subsection{Resources}

This vignette will cover all of the material you need to know to efficiently
analyze data in \poppr{}. For information on methods of analysis (eg. index of
association, distance measures, AMOVA, ...), please read the manual pages
provided for each function.

As \poppr{} expanded from version 1.0, the vignette also expanded to be 80+
pages. As a result, it became clear that over 22,000 was less of a manual and
more of a novella with a terrible plot. To remedy this, this vignette will focus
only on data manipulation and a separate vignette, ``algo", has been written
to give algorithmic details of analyses introduced with \poppr{}.

As of spring 2014, Drs. Niklaus J. Gr\"unwald, Sydney E. Everhart, and I have
co-authored a primer on using R for population genetic analysis. It is located
at \url{http://grunwaldlab.github.io//Population_Genetics_in_R} and the source
code can be found
\href{https://github.com/grunwaldlab/Population_Genetics_in_R}{on our github
site}.

\subsection{Getting Help}

If you have any questions or feedback, feel free to send a message to the
\poppr{} forum at \url{http://groups.google.com/group/poppr}. You can submit bug
reports there or on our github site: \url{https://github.com/grunwaldlab/poppr}

\subsection{Acknowledgments}

Much thanks goes to Sydney E. Everhart for alpha testing, beta testing, feature
requests, proofreading, data contribution, and moral support throughout the
writing of this package and manual. Thanks also to Brian Knaus, Ignazio Carbone,
David Cooke, Corine Schoebel, Jane Stewart, and Zaid Abdo for beta testing and
feedback.

The following data sets are included in \poppr{}:

\begin{itemize}
  \item \texttt{Pinf} (SSR, \textit{Phytophthora infestans})\citep{goss2014irish}
  \item \texttt{monpop} (SSR, \textit{Monilinia fructicola})\citep{everhart2014finescale}
  \item \texttt{Aeut} (AFLP, \textit{Aphanomyces eutieches})\citep{Grunwald:2006}
  \item \texttt{Pram} (SSR, \textit{Phytophthora ramorum})\citep{kamvar2015spatial, goss2009population}
\end{itemize}

% \newpage
\subsection{Citation}

To cite \poppr{}, please type
in your R console:

<<popprcite, eval = TRUE, size="normalsize">>=
citation(package = "poppr")
@

The formal publication for the first version of \poppr{} was published in the
journal \textbf{PeerJ}: \url{http://peerj.com/articles/281/} \citep{kamvar2014poppr}. The new features
in version 2.x were published in \textbf{Frontiers}
\url{http://dx.doi.org/10.3389/fgene.2015.00208} \citep{kamvar2015novel}. 

\section{Installation and Quick Start}
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Installation}
\label{intro:install}


This manual assumes you have installed R. If you have not,
please refer to The CRAN home page at \url{http://cran.r-project.org/}. We also
recommend the Rstudio IDE (\url{http://www.rstudio.com/}), which allows the user
to view the R console, environment, scripts, and plots in a single window.

\subsubsection{From CRAN}
\tab\tab To install \poppr{} from CRAN, select ``Package
Installer" from the menu ``Packages \& Data" in the GUI or type:

<<install, eval=FALSE>>=
install.packages("poppr", dependencies=TRUE)
@


All dependencies (\textit{adegenet, pegas, vegan, ggplot2, phangorn, ape,
reshape2} and \textit{igraph}) will also be installed. In the unfortunate case
this does not work, consult
\url{http://cran.r-project.org/doc/manuals/R-admin.html#Installing-packages}.

\subsubsection{From GitHub}
\tab\tab GitHub is a repository where you can find all stable and development
versions of \poppr{}. 

Since \poppr{} contains C code, it needs to be compiled, which means that you
need a working C compiler. If you are on Linux, you should have that, but if you
are on Windows or OSX, you might need to download some special tools:

\begin{description}
  \item[Windows] Download Rtools: \url{http://cran.r-project.org/bin/windows/Rtools/}
  \item[OSX] Download Xcode: \url{https://developer.apple.com/xcode}
\end{description}

To install from GitHub, you do not need to download the tarball since
there is a package called \textit{devtools} that will download and install the
package for you directly from GitHub. After you have installed all dependencies
(see above section), you should download \textit{devtools}:

<<install_devtools, eval = FALSE>>=
install.packages("devtools")
@
Now you can execute the command \texttt{install\_github} with the user and
repository name:

<<install_github, eval = FALSE>>=
devtools::install_github("grunwaldlab/poppr")
@

If you are the adventurous type and are willing to test out unreleased versions
of the package, you can also install the development version:

<<install_devel, eval = FALSE>>=
devtools::install_github("grunwaldlab/poppr@devel")
@

Users who install this version do so at their own risk. Since it is a
development version, documentation may be incomplete or non-existent for new
functions.

\subsubsection{From Source}

\tab\tab The tarball for \poppr{} can be downloaded from CRAN:
\url{http://cran.r-project.org/package=poppr} or via github at
\url{https://github.com/grunwaldlab/poppr}.

You will need a C compiler to install this way. See the section above for details.

If you choose to install \poppr{} from a source file, you should first make sure
to install all of the dependencies with the following command:

<<install_depend, eval=FALSE, tidy = FALSE>>=
pkgs <- c("adegenet", "pegas", "vegan", "ggplot2", "phangorn", "ape", 
          "igraph", "reshape2", "dplyr", "shiny")
install.packages(pkgs)
@

After installing dependencies, download the package to your computer and then
install it with:
<<install_source, eval=FALSE>>=
install.packages("/path/to/poppr.tar.gz", type="source", repos=NULL)
@



%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Quick start}
\label{intro:qstart}

\tab\tab The author assumes that if you have reached this point in the manual,
then you have successfully installed R and \poppr{}. Before proceeding, you
should be aware that R is case sensitive. This means that the words ``Case" and
``case" are different. You should also know where your R package library is
located. In this section, you will learn how to locate a file, import it to R,
and make a first analysis using the \texttt{poppr()} function.

\begin{center}
   \fcolorbox{light-gray}{light-gray}{
        \begin{minipage}[t]{0.8\textwidth}
          {\large \textsc{What or where is my R package library?}}\\
          R is as powerful as it is through a community of people who submit
          extra code called ``packages" to help it do specific things. These
          packages live in a certain place on your computer called an R library.
          You can find out where this library is by typing \texttt{.libPaths()}
        \end{minipage}
    }
\end{center}

Importing a file into R involves you knowing the path to your file and then
typing that into R's console. \texttt{getfile()} will help provide a point and
click interface for selecting a file. This is simply a tool to help you get 
started. As you get better with R, you might feel that you don't need it at all.

First, tell your computer to search R's library, load the \poppr{} package, and 
use \texttt{getfile()}:

<<echo=FALSE>>=
library("poppr")
x <- list(files="/path/to/R/poppr/files/rootrot.csv", path="/path/to/R/poppr/files")
@

<<getfilefunk, eval=FALSE>>=
library("poppr")
x <- getfile()
@

A pop up window will appear like this\footnote{This window
sometimes appears behind your current session of R, depending on the GUI and you
will have to toggle to this window}:

\begin{figure}[h!]
  \centering
  \caption{\footnotesize \footnotesize A popup window as it appears in OSX (Mountain Lion).}
  \label{getfile window}
  \includegraphics{getfile}
\end{figure}
\newpage

\begin{center}
   \fcolorbox{light-gray}{light-gray}{
      \begin{minipage}[t]{0.8\textwidth}
        {\large \textsc{Hey! My window doesn't look like that!}}\\
        Now, this window will not match up to your window on your computer
        because you will probably not be in the right directory. Remember the
        first path in \texttt{.libPaths()}? Move to a folder called
        \textbf{poppr} in that path. In that folder, you will find another
        folder called \textbf{files}. Move there and your window will match the
        one displayed.
      \end{minipage}
    }
\end{center}

You should navigate to your R library and select the file called ``rootrot.csv''.
If you don't know where your the poppr package lives, you can find it by typing
\texttt{find.package('poppr')} into the R command line. Once we select a file,
the file name and its path will be stored in the variable, \texttt{x}. We can 
confirm that by typing \texttt{x} into R's command line.

<<getfilex>>=
x
@

Here we can see that \texttt{x} is a list with two entries: \texttt{\$files}
shows the files you selected and \texttt{\$path} shows the path to
those files.
\begin{center}
  \fcolorbox{light-gray}{light-gray}{
    \begin{minipage}[t]{0.8\textwidth}
      {\large \textsc{Not sure what I mean by path or working directory?}}\\
      For anyone who has never used a command line, this is a new concept. You
      can think of the path as an address. So instead of
      \texttt{"/path/to/R"}, you could have \texttt{"/USA/Oregon/Corvallis"}.
      Or on your computer, it could be
      \texttt{"C:/users/poppr-user/R/win-library/3.1"} on Windows (where ``poppr-user"
       is your username) or
      \texttt{"/Library/Frameworks/R.framework/Versions/3.1/Resources/library"}
      on OSX. Each slash represents a folder that you would click on when
      you are using the mouse.

      A working directory is the folder that R is working in. It is where
      you can access and write files. When you tell R to read a file, it will
      only look for that file in your working directory. Note that you will not
      endanger your files by reading them into R. R works by making a copy of
      the file into memory. This means that you can manipulate the data in any
      way that you want without ever changing the original file.\\

      To find what your current working directory is set to, type
      \texttt{getwd()} into the R console. Usually, you will start off a session
      in your ``home" directory, which will look like this: \texttt{"$\sim$/"}.
      The command \texttt{setwd()} will change your working directory to any
      folder of your choice on your computer as indicated by the path that you
      provide. For more information, see Quick R at
      \url{http://www.statmethods.net}.
    \end{minipage}
  }
\end{center}

We will use \texttt{x\$files} to access the file. The file is in the 
\seclink{intro:import:read.genalex}{GenAlEx} format, so we will import it using
\cmdlink{intro:import:read.genalex}{read.genalex()} and then analyze it with
the function \texttt{poppr()} to get a table of diversity indices per population. 

<<firstpoppr, eval=FALSE>>=
myData  <- read.genalex(x$files)
myData
popdata <- poppr(x$files)
@

<<aflp, echo=FALSE>>=
options(width=90)
popprsoutput <- poppr(system.file("files/rootrot.csv", package="poppr"))
@

The output of \texttt{poppr()} was assigned to the variable \texttt{popdata}, so
let's look at the data.

<<firstpoppr2, eval=FALSE>>=
popdata
@

<<aflp2, echo=FALSE>>=
popprsoutput
@
The fields you see in the output include:
\begin{itemize}
  \item \texttt{Pop -} Population name (Note that ``Total" also means
  ``Pooled").
  \item \texttt{N -} Number of individuals observed.
  \item \texttt{MLG -} Number of multilocus genotypes (MLG) observed.
  \item \texttt{eMLG -} The number of expected MLG at the smallest sample size
  $\geq 10$ based on rarefaction. \citep{Hurlbert:1971}
  \item \texttt{SE -} Standard error based on \texttt{eMLG} \citep{Heck:1975}
  \item \texttt{H -} Shannon-Wiener Index of MLG diversity. \citep{Shannon:1948}
  \item \texttt{G -} Stoddart and Taylor's Index of MLG diversity.
  \citep{Stoddart:1988}
  \item \texttt{lambda -} Simpson's index, $\lambda$.
  \item \texttt{E.5 -} Evenness, $E_5$. \citep{Pielou:1975}\citep{Ludwig:1988}\citep{Grunwald:2003}
  \item \texttt{Hexp -} Nei's 1978 Expected Heterozygosity. \citep{Nei:1978}
  \item \texttt{Ia -} The index of association, $I_A$. \citep{Brown:1980}
  \citep{Smith:1993} \citep{Agapow:2001}
  \item \texttt{rbarD -} The standardized index of association, $\bar{r}_d$.
  \citep{Agapow:2001}
\end{itemize}

These fields are further described in the function \texttt{poppr}. You can
access the help page for \texttt{poppr} by typing \texttt{?poppr} in your R
console.

One thing to note about this output is the \texttt{NaN} in the column labeled
\texttt{SE}. In R, \texttt{NaN} means ``Not a number''. This is produced from
calculation of a standard error based on rarefaction analysis. Occasionally,
this calculation will encounter a situation in which it must attempt to take a
square root of a negative number. Since the root of any negative number is not
defined in the set of real numbers, it must therefore have an imaginary
component, $i$. Unfortunately, R will not represent the imaginary components of
numbers unless you specifically tell it to do so. By default, R represents these
as \texttt{NaN}.\\

\section{Import and Data types}
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Importing data into poppr \{Get out of my dreams and into my R\}}
\label{intro:import}

\subsubsection{How does R represent data? \{Objective: data\}}

Working with data in R means that these data have to be stored inside an
``object'', which is stored in the computer's memory. Because of this, it's
important to know the difference between a \textbf{file} and an \textbf{object}.
When anyone talking about importing a \textbf{file} into R, they are referring
to a spreadsheet or text file that lives in a folder on your hard drive.
Spreadsheet files (saved as *.csv files) are normally imported through the R
function \texttt{read.table()}. The output of \texttt{read.table()} is a
\texttt{data.frame}. A \texttt{data.frame} is an \textbf{object} represented in
your computer's memory. This means that it only exists for as long as R is
running.

The good thing about having objects stored in memory is that you can manipulate
them in any way and not affect the source of those data. Since R is a scripted
language (instead of point-and-click), any of your manipulations can be saved in
a separate R file that can be easily adapted to new data. Of course, most data
are not going to be entered into R manually. Usually they will be formatted in a
manner that can be read by popular population genetics programs.

As previously mentioned, since \poppr{} is based on \adegenet{}, it's possible
to read in the following file formats into a \texttt{genind} object with the
function \texttt{import2genind()}:

\begin{itemize}
  \item{\textsc{Fstat}}
  \item{\textsc{Genepop}}
  \item{\textsc{Genetix}}
  \item{\textsc{Structure}}
\end{itemize}

Here, we introduce a new way of importing data into a \texttt{genind} or
\texttt{genclone} object from a \textsc{GenAlEx} formatted file. 

\subsubsection{Function: read.genalex}
\label{intro:import:read.genalex}

\tab\tab A very popular program for population genetics is GenAlEx
(\url{http://biology.anu.edu.au/GenAlEx/Welcome.html})
\citep{Peakall:2012, Peakall:2006}. GenAlEx runs within the Excel environment and
can be very powerful in its analyses. \Poppr{} has added the ability to read
*.CSV files\footnote{*.CSV files are comma separated files that are easily
machine readable.} produced in the GenAlEx format. It can handle data types
containing regions and geographic coordinates, but currently cannot import
allelic frequency data from GenAlEx. Using the \poppr{} function
\texttt{read.genalex} will import your data into \adegenet{}'s \texttt{genind}
object or \poppr{}'s \texttt{genclone} object (more information on that below).
For ways of formatting a GenAlEx file, see the manual here:
\url{http://biology.anu.edu.au/GenAlEx/Download_files/GenAlEx\%206.5\%20Guide.pdf}


Below is an example of the GenAlEx format. We will use the data set called
\texttt{microbov} from the \adegenet{} package to generate it. The data contains
three demographic factors: Country, Species and Breed contained within the
\texttt{@other} slot (detailed in \seclink{intro:genind:other}{The other slot}).
We will first set these as the population strata, define the population as the
combination of the strata, and then save a file to the desktop. 

<<microsave, eval=FALSE>>=
library("poppr")
data(microbov)
strata(microbov) <- data.frame(other(microbov)) # set the strata
setPop(microbov) <- ~coun/breed/spe             # combine the strata
microbov
genind2genalex(microbov, file = "~/Desktop/microbov.csv")
@

<<microsave_message, echo=FALSE>>=
cat("Extracting the table ... Writing the table to ~/Desktop/microbov.csv ... Done.")
@

\setkeys{Gin}{width=\textwidth}

\begin{figure}[h!]
  \centering
  \caption{\footnotesize \footnotesize The first 15 individuals and 4 loci of
  the microbov data set. The first column contains the individual names, the
  second column contains the population names, and each subsequent column
  represents microsatellite genetic data. Highlighted in red is a list of
  populations and their relative sizes.}
  \label{microbov unmodified}
\includegraphics{unmod_dat}
\end{figure}

The GenAlEx format contains individuals in rows and loci in columns. Individual
data begins at row 4. Column A always contains individual names and column B
defines the population of each individual. Notice here that the three
demographic factors from the data have been concatenated with a ``\_''. This
allows us to import more than one population factor to use as hierarchical
levels in a \seclink{intro:genclone}{genclone object.}

\newpage

The First three rows contain information pertaining to the global data set. The
only important information for \poppr{} is the information contained in row 3
and the first three columns of row 1.

\begin{table}[h!]
\centering
\begin{tabular}{|l|l|l|l|ll|}
  \hline
 & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} & \\
  \hline
 \textbf{1} & \# of Loci & \# of Individuals & \# of Populations & Pop1 Size & ...\\
 \hline
 \textbf{2} & - & - & - & Pop1 Name & ...\\
 \hline
 \textbf{3} & - & - & Locus 1 & ... & \\
  \hline
\end{tabular}
\end{table}

Highlighted in red in figure \ref{microbov unmodified} are definitions of the
number of populations and their respective sizes. As this is redundant
information, we can remove it. Below is an example of a valid data set that can
be imported into \poppr{}.

\begin{figure}[h!]
  \centering
  \caption{\footnotesize \footnotesize The first 15 individuals and 4 loci of
  the microbov data set. This is the same figure as above, however the
  populations and counts have been removed from the header row and the third
  number in the header has been replaced by 1.}
  \label{microbov modified}
\includegraphics{mod_dat}
\end{figure}

\setkeys{Gin}{width=0.5\textwidth}

All GenAlEx formatted data can be imported with the command \texttt{read.genalex},
detailed below:
\newpage
\tline{}
\begin{quote}
Default Command:
<<read.genalex_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "read.genalex"
print_command(funk)
@
\end{quote}
\begin{itemize}
  \item \texttt{genalex -} a *.CSV file exported from GenAlEx on your disk (For
  example: \texttt{"my\_genalex\_file.csv"}).
  \item \texttt{ploidy -} a number indicating the ploidy for the data set (eg 2
  for diploids, 1 for haploids).
  \item \texttt{geo -} GenAlEx allows you to have geographic data within your
  file. To do this for \poppr{}, you will need to follow the first format
  outlined in the GenAlEx manual and place the geographic data AFTER all genetic
  and demographic data with one blank column separating it (See the GenAlEx
  Manual for details). If you have geographic information in your file, set this
  flag to \texttt{TRUE} and it will be included within the resulting genind
  object in the \texttt{@other} slot. (If you don't know what that is, don't
  worry. It will be explained later in \seclink{intro:genind:other}{The other
  slot.})
  \item \texttt{region -} To format your GenAlEx file to include regions, you
  can choose to include a separate column for regional data, or, since regional
  data must be in contiguous blocks, you can simply format it in the same way
  you would any other data (see the GenAlEx manual for details). If you have
  your file organized in this manner, select this option and the regional
  information will be stored in the \texttt{@other} slot of the resulting
  \texttt{genind} object or be incorporated into the hierarchy of the \texttt{genclone} object.
  \item \texttt{genclone -} This flag will convert your data into a
  \texttt{genclone} object (see \seclink{intro:genclone}{Send in the clones} for
  more info).
  \item \texttt{sep -} The separator argument for columns in your data. It
  defaults to ``,".
  \item \texttt{recode -} If your data is polyploid data, this gives you the 
  option to recode it. (See \seclink{intro:import:polyploid}{About Polyploid
  Data} for details)
\end{itemize}
\bline{}
\begin{center}
  \fcolorbox{light-gray}{light-gray}{
    \begin{minipage}[t]{0.8\textwidth}
      {\large \textsc{If you are unfamiliar with exporting data from Excel}}\\
      \begin{enumerate}
        \item Click the Microsoft Office Button in the top left corner of Excel.
        (Or go to the File menu if you have an older version)
        \item Click Save As...
        \item In the ``Save as type" drop down box, select CSV (comma delimited).
      \end{enumerate}
    \end{minipage}
  }
\end{center}

Note that regional data and geographic data are not mutually exclusive. You can
have both in one file, just make sure that they are on the same sheet and that
the geographic data is always placed after all genetic and demographic data.

We have a short example of \textsc{GenAlEx} formatted data with no geographic or
regional formatting. We will first see where the data is using the command
\texttt{system.file()}

<<system_file_genalex, eval=FALSE>>=
system.file("files/rootrot.csv", package="poppr")
@

<<system_file_echo, echo=FALSE>>=
paste("/path/to/R/library/poppr/files/rootrot.csv")
@

Now import the data into \poppr{} like so:
<<read.genalex_ex>>=
rootrot <- read.genalex(system.file("files/rootrot.csv", package="poppr"))
@

Executing rootrot shows that this file is now in \texttt{genclone} format and can be used
with any function in \poppr{} and \adegenet{}
<<read.genalex_ex2>>=
rootrot
@


\subsubsection{Other ways of importing data}
\label{intro:import:other}

\tab\tab \Adegenet{} already supports the import of \textsc{FSTAT}, \textsc{Structure}, \textsc{Genpop},
and \textsc{Genetix} formatted files, so if you have data in those formats, you can
import them using the function \texttt{import2genind}. For sequence data, check
if you can use \texttt{read.dna} from the \textit{ape} package to import your
data. If you can, then you can use the \adegenet{} function
\texttt{DNAbin2genind}. If you don't have any of these formats handy, you can
still import your data using R's \texttt{read.table} along with
\texttt{df2genind} from \adegenet{}. For more information, see \adegenet{}'s
``Getting Started" vignette.

\subsubsection{Function: genind2genalex (exporting data)}
\label{intro:import:genind2genalex}

\tab\tab Of course, being able to export data is just as useful as being able to
import it, so we have this handy little function that will write a GenAlEx
formatted file to wherever you desire.\\
\textbf{WARNING: This will overwrite any file that exists with the same name.}

\tline{}
\begin{quote}
Default Command:
<<genind2genalex_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "genind2genalex"
print_command(funk)
@
% \texttt{genind2genalex(pop, filename = "genalex.csv", quiet = FALSE)}
\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{filename -} This is where you specify the path to the new file
  you wish to create. If you specify only a filename with no path, it will place
  the file in your current working directory.
  \item \texttt{quiet -} If this is set to \texttt{FALSE}, a status message will
  be printed to the console as the extraction progresses.
  \item \texttt{geo -} Set to \texttt{TRUE}, if you have a data frame or matrix
  in the  \texttt{@other} slot of your \texttt{genind} object that contains geographic
  coordinates for all individuals or all populations. Setting this to
  \texttt{TRUE} means the resulting file will have two extra columns at the end
  of your file with geographic coordinates.
  \item \texttt{geodf -} The name of the data frame or matrix containing the
  geographic coordinates.
  \item \texttt{sep -} A separator to separate columns in the resulting file.
\end{itemize}
\bline{}

First, a simple example for the rootrot data we demonstrated in section 1.4.2:
<<genind2genalex, eval=FALSE>>=
genind2genalex(rootrot, "~/Desktop/rootrot.csv")
@
<<genind2genalex_cat, echo=FALSE>>=
cat("Extracting the table ... Writing the table to ~/Desktop/rootrot.csv ... Done.\n")
@

Here's an example of exporting the nancycats data set into \textsc{GenAlEx}
format with geographic information. If we look at the nancycats geographic
information, we can see it's coordinates for each population, but not each
individual:

<<nancyxy>>=
data(nancycats)
nancycats@other$xy
@

To export it:
<<genind2genalex_nancy, eval=FALSE>>=
genind2genalex(nancycats, "~/Desktop/nancycats_pop_xy.csv", geo = TRUE)
@

<<genind2genalex_cat2, echo=FALSE>>=
cat("Extracting the table ... Writing the table to ~/Desktop/nancycats_pop_xy.csv ... Done.\n")
@
If we wanted to assign a geographic coordinate to each individual, we can use
this trick knowing that there are 17 populations in the data set:
<<nancy_grow_xy>>=
nan2 <- nancycats
nan2@other$xy <- nan2@other$xy[rep(1:17, table(pop(nan2))), ]
head(nan2@other$xy)
@

Now we can export it to a different file.
<<genind2genalex_nancy_grow, eval=FALSE>>=
genind2genalex(nan2, "~/Desktop/nancycats_inds_xy.csv", geo = TRUE)
@
<<genind2genalex_cat3, echo=FALSE>>=
cat("Extracting the table ... Writing the table to ~/Desktop/nancycats_inds_xy.csv ... Done.\n")
@
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Getting to know \adegenet{}'s \texttt{genind} object}
\label{intro:genind}

\tab\tab Since \poppr{} was built around \adegenet{}'s framework, it is
important to know how \adegenet{} stores data in the \texttt{genind} object, as that is
the object used by \poppr{}. To create a \texttt{genind} object, \adegenet{} takes a data
frame of genotypes (rows) across multiple loci (columns) and converts them into
a matrix of individual allelic counts at each locus \citep{Jombart:2008}.

For example, Let's say we had data with 3 diploid individuals each with 3 loci
that had 3, 4, and 5 allelic states respectively:

% latex table generated in R 3.1.0 by xtable 1.7-3 package
% Sat Apr 19 19:03:55 2014
\begin{table}[ht]
\centering
\begin{tabular}{rlll}
  \hline
 & locus1 & locus2 & locus3 \\
  \hline
1 & 101/101 & 201/201 & 301/302 \\
  2 & 102/103 & 202/203 & 301/303 \\
  3 & 102/102 & 203/204 & 304/305 \\
   \hline
\end{tabular}
\label{example_table}
\end{table}
\noindent
The resulting \texttt{genind} object would contain a matrix that has 3 rows and
12 columns. Below is a schematic of what that would look like. Each column
represents a separate allele, each row represents an individual and each color
represents a different locus.

<<ex_data_picture, echo = FALSE, fig.width=14, fig.height=4, out.width="7in", out.height = "2in">>=
library("adegenet")
df <- data.frame(list(locus1=c("101/101", "102/103", "102/102"),
                      locus2=c("201/201", "202/203", "203/204"),
                      locus3=c("301/302", "301/303", "304/305")))
dat <- tab(df2genind(df, sep="/"))
tdat <- dat
tdat[] <- 1
x <- barplot(tdat, axes = FALSE, axisnames = FALSE)
barplot(rep(3, 12), col = rep(rainbow(3, alpha = 0.5), 3:5), axes = FALSE, add = TRUE)
axis(2, at = 1:3 - 0.5, labels = 1:3, tick = FALSE)
axis(3, at = x, labels = colnames(tdat), tick = FALSE)
axis(1, at = c(2, 6.125, 11.5), labels = names(df), tick = FALSE)
@
\noindent
When we look at the data derived from table \ref{example_table}, we see that we
have a matrix of individual allele counts at each locus.
<<ex_genind, echo=FALSE>>=
dat
@
\noindent
At each locus, the allele counts for each individual sum to the ploidy, $p$.
Homozygotes are denoted as having an allele count of $p$ at a single allele
within a locus, while heterozygotes have their allele counts represented as $<
p$ wher $p$ = ploidy across multiple alleles in a single locus. Along with this
matrix, are elements that define the names of the individuals, loci, alleles,
and populations. If you wish to know more, see the \adegenet{} ``Getting
Started'' manual.

\subsubsection{The other slot}
\label{intro:genind:other}

The other slot is a place in the \texttt{genind} object that can be used to store useful
information about the data. We saw earlier that it could store demographic
information, now let's explore a different example. Bruvo's distance is based
off of a stepwise mutation model for microsatellites. This requires us to know
the length of the repeat of each locus. We could store the repeat lengths in a
separate variable in our R environment, but we are at risk of losing that. One
way to prevent it from being lost would be to place it in the ``other'' slot.
For the purpose of this example, we will use the ``nancycats'' data set from the
\adegenet{} package and assume that it has di-nucleotide repeats at all of its
loci.

<<other_replen>>=
data(nancycats) # Load the data
other(nancycats) # geographical coordinates
repeats <- rep(2, nLoc(nancycats)) #nLoc = number of loci
repeats
other(nancycats)$repeat_lengths <- repeats
other(nancycats) # two items named xy and repeat_lengths
@

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{The \texttt{genclone} object \{send in the clones\}}
\label{intro:genclone}

The \texttt{genclone} class was defined in order to make working with clonal
organisms more intuitive. It is built off of the \texttt{genind} object and has
dedicated slots for defined multilocus genotypes. The name \texttt{genclone} refers to
the fact that it has the ability to handle genotypes of clonal organisms (but it
is also used for sexual populations).

In previous versions of \poppr{}, the \texttt{genclone} object contained a hierarchy slot
as well. This slot was moved to \adegenet{} and its name was changed to 
``strata''. This slot allows you to carry around several definitions for 
populations in the same data set.

The function \texttt{as.genclone} allows the user to convert a \texttt{genind}
object to a \texttt{genclone} object. The following example will demonstrate
that the \texttt{genclone} object is an extension of the \texttt{genind} object
as well as the advantages of having populations pre-defined in your data set.

\subsubsection{Function: as.genclone}
\label{intro:genclone:as.genclone}

\tline{}
\begin{quote}
Default Command:
<<as.genclone_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "as.genclone"
print_command(funk)
@
\end{quote}
\begin{itemize}
  \item \textbf{x -} a \texttt{genind} object to be converted.
  \item \textbf{... -} any arguments to be passed to the \texttt{genind} constructor.
  \item \textbf{mlg -} a vector representing the multilocus genotype definitions of your data.
  \item \textbf{mlgclass -} if \texttt{TRUE}, the MLGs represented in your
  object will be converted to an MLG class object, which allows for custom MLG
  definitions.
\end{itemize}
\bline{}

Let's show an example of a \texttt{genclone} object. First, we will take an
existing \texttt{genind} object and convert it using the function
\texttt{as.genclone} (We can also use the function
\cmdlink{intro:import:read.genalex}{read.genalex} to import as \texttt{genclone}
or \texttt{genind} objects). We will use the \texttt{Aeut} data set because it
is a clonal data set that has a simple population strata
\citep{Grunwald:2006}. The data set is here:
\url{http://dx.doi.org/10.6084/m9.figshare.877104} and it is AFLP data of the
root rot pathogen \textit{Aphanomyces euteiches} collected from two different
fields in NW Oregon and W Washington, USA. These fields were divided up into
subplots from which samples were collected. The fields represent the population
and the subplots represent the subpopulation. Let's take a look at what the
\texttt{genind} object looks like:

<<show_genind>>=
library("poppr")
data(Aeut)
Aeut
@

We can see that there is a data frame in the  \texttt{@other} slot called
``population\_hierarchy". This is left over from \poppr{} version 1.x behavior.
Since the \texttt{genind} object now has a \texttt{@strata} slot, we can use it
to set the stratification (previously called ``hierarchy'').

<<add_strata_Aeut>>=
strata(Aeut) <- other(Aeut)$population_hierarchy[-1]
Aeut
@

Now we can convert this to a \texttt{genclone} object, which will store
information about our multilocus genotypes for us.

<<as_genclone>>=
agc <- as.genclone(Aeut)
agc
@

We can see here that it shows less information, but it gives us a very simple
overview of our data. Don't be fooled, however, because it contains the same
information as a \texttt{genind} object.

<<genclone_compare>>=
c(is.genind(Aeut), is.genclone(Aeut), is.genind(agc), is.genclone(agc))

# Adegenet functions work the same, too
c(nInd(Aeut), nInd(agc))
@

If we wanted to, we could also convert it back to a \texttt{genind} object.
\label{function:genclone2genind}

<<genclone2genind>>=
genclone2genind(agc)
@
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{About polyploid data}
\label{intro:import:polyploid}

\begin{center}
  \fcolorbox{light-gray}{salmon}{
    \begin{minipage}[t]{0.8\textwidth}
      {\begin{center} \jala{}\jala{} \textbf{WARNING}\revjala{}\revjala{}\end{center}}
      Treat polyploid data with care. Please read this section carefully and
      consult the help pages for all functions mentioned here.
    \end{minipage}
  }
\end{center}

With diploid or haploid data, genotypes are unambiguous. It is often
clear when it is homozygous or heterozygous. With polyploid data, genotypes can
be ambiguous. For example, a tetraploid individual with the apparent genotype of
\textbf{A/B} could actually have one of three genotypes: \textbf{A/A/A/B},
\textbf{A/A/B/B}, or \textbf{A/B/B/B}. This ambiguity prevents a researcher from
accurately calling all alleles present. In \adegenet{}, it was previously
difficult to import polyploid data because of this ambiguity as data was
required to be unambiguous or missing.

A solution to this problem is to code missing alleles as ``0''. An example of
this is found within the \texttt{Pinf} data set in \poppr{} 
\citep{goss2014irish}. First, we will look at where we have polyploid allele 
calls.

<<pinf_table, fig.width = 5, fig.height = 15>>=
data(Pinf)
Pinf
ptab <- info_table(Pinf, type = "ploidy", plot = TRUE)
@

We look at the last six samples over two loci, Pi63 (3 alleles, triploid) and
Pi70 (3 alleles, diploid) to examine how the data is represented.

<<pinf_show>>=
tail(tab(Pinf[loc = locNames(Pinf)[9:10]]))
@
\noindent
Each column in this data represents a different allele at a particular locus.
\texttt{Pi63.148} is the allele \texttt{148} at locus \texttt{Pi63}. Each row is
an individual. The numbers represent the fraction of a given allele that makes
up the individual genotype at a particular locus. What we can see here is that
the number of columns is 8 when we expect only 6 (2 loci $\times$ 3 alleles).
The first allele at each locus is \texttt{000}. Let's take a look at the data in
a human-readable format.

<<pinf_show_df>>=
Pinfdf <- genind2df(Pinf, sep = "/")
tail(Pinfdf[10:11])
@

\noindent
It's more clear now that we have a data set of tetraploid individuals where some
genotypes appear diploid (\texttt{\Sexpr{Pinfdf[85, 10]}}) and some appear
triploid (\texttt{\Sexpr{Pinfdf[86, 10]}}). The tetraploid genotype is padded
with zeroes to make up the difference in ploidy.

%% TODO: ZHIAN FIX THIS

This method allows \textsc{Bruvo's Distance} \citep{Bruvo:2004} and the
\textsc{Index of Association} \citep{Brown:1980,Smith:1993,Agapow:2001} to work
with polyploids as they specifically recognize the zeroes as being missing data.
A side effect, unfortunately is that the extra zeroes appear as extra alleles.
As this affects all frequency-based statistics (except for the ones noted
above), the user should reformat their data set with the function
\texttt{recode\_polyploids}, which will remove the zeroes.

<<pinf_recode>>=
Pinf_rc <- recode_polyploids(Pinf, newploidy = TRUE)
Pinf_rc # Notice that the new ploidy is accounted for.
tail(tab(Pinf_rc[loc = locNames(Pinf_rc)[9:10]]))
@
\noindent
Below, we show the observed genotypes:

<<pinf_recode_df>>=
Pinfrcdf <- genind2df(Pinf_rc, sep = "/")
tail(Pinfrcdf[10:11])
@

If you have imported your data as recoded polyploid data, you can use the 
argument ``addzero'' to fill out the ploidy:

<<pinf_rerecode>>=
tail(tab(recode_polyploids(Pinf_rc[loc = locNames(Pinf_rc)[9:10]], addzero = TRUE)))
@
%=============================================================================%
%=============================================================================%
%
%
%
%=============================================================================%
%=============================================================================%
\section{Data Manipulation}
\label{data.manip}

\tab\tab One tedious aspect of population genetic analysis is the need for
repeated data manipulation. \Poppr{} includes novel functions for clone-
censoring your data sets, removing genotypes or loci with missing data, removing
uninformative loci, and shuffling populations.

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Replace or remove missing data \{Inside the golden days of missing data\}}
\label{data.manip:missing}

\tab\tab A data set without missing data is always ideal, but often not
achievable. 
% Many functions in \adegenet{} cannot handle missing data and thus
% the function \texttt{na.replace} exists \citep{Jombart:2008}. It will replace
% missing data with with either ``0" representing a mysterious extra allele in the
% data set resulting in more diversity or the mean of allelic frequencies at the
% locus. 
The \poppr{} function \texttt{missingno} exists to handle missing data. Missing
data can mean different things based on your data type. For microsatellites,
missing data might represent any source of error that could cause a PCR product
to not amplify in gel electrophoresis, which may or may not be biologically
relevant. For a DNA alignment, missing data could mean something as simple as an
insertion or deletion, which is biologically relevant. The choice to exclude or
estimate data has very different implications for the type of data you have.

\begin{center}
  \fcolorbox{light-gray}{salmon}{
    \begin{minipage}[t]{0.8\textwidth}
      {\begin{center} \jala{}\jala{} \textbf{WARNING}\revjala{}\revjala{}\end{center}}
      Treatment of Missing data is a non-trivial task. You should understand the nature of missing data in your data set before treatment.
    \end{minipage}
  }
\end{center}

\tline{}
\subsubsection{Function: missingno}
\label{data.manip:missing:missingno}

\tab\tab \texttt{missingno} is a function that serves as a way to exclude
specific areas that contain systematic missing data. There are four methods
available, 

\begin{quote}
Default Command:
<<missingo_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "missingno"
print_command(funk)
@
% \texttt{missingno(pop, type = "loci", cutoff = 0.05, quiet = FALSE)}
\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{type -} This could be one of four options:
    \begin{description}
      \item[``loci"] This is to be used for a data set that has systematic
      problems with certain loci that contain null alleles or simply failed to
      amplify. This will remove loci with a defined threshold of missing data
      from the data set.
      \item[``geno"] This is to be used for genotypes (individuals) in your
      data set where many null alleles are present. Individuals with a defined
      threshold missing data will be removed.
      \item[``ignore'' or ``asis''] This argument will retain missing data in your data
      set. It's useful for functions that utilize \texttt{missingno} internally,
      such as \texttt{mlg.filter()}, \texttt{poppr.amova()}, or \texttt{aboot()}.
      \item[``mean''] This replaces missing data with the mean allele
      frequencies in the entire data set \textcolor{red}{(This is for backwards compatibility, please don't use this)}.
      \item[``zero" or ``0"] This replaces missing data with zero, signifying a
      new allele \textcolor{red}{(This is for backwards compatibility, please don't use this)}.
    \end{description}
    \item \texttt{cutoff -} This is a numeric value from 0 to 1 indicating the
    percent allowable missing data for either loci or genotypes. If you have,
    for example, two loci containing missing 5\% and 10\% missing data,
    respectively and you set \texttt{cutoff = 0.05}, \texttt{missingno} will
    remove the second locus. Percent missing data for genotypes is considered
    the percent missing loci over number of total loci.
    \item \texttt{quiet -} When this is set to \texttt{FALSE}, the number of
    missing values replaced will be printed to screen if the method is ``zero"
    or ``mean". It will print the number of loci or individuals removed if the
    method is ``loci" or ``geno".
    \item \texttt{freq -} This is used for compatibility with the \texttt{tab()}
    method for \texttt{genind} object. It will convert counts of alleles to 
    frequencies of alleles, rendering an object that will return warnings. 
\end{itemize}
\bline{}

Let's take a look at what this does by focusing in on areas with missing data.
We'll use the data set \texttt{nancycats} as an example. Using the \poppr{}
function \texttt{info\_table}, we can assess missing data within populations.

<<initializing_poppr, out.width=".8\\linewidth", fig.height = 6, fig.width = 10>>=
library("poppr")
data(nancycats)
info_table(nancycats, plot = TRUE)
@
\label{function:info-table}

We can see that locus \Sexpr{locNames(nancycats)[1]} has a lot of missing data.
To demonstrate the function \cmdlink{data.manip:missing:missingno}{missingno},
we will zoom into the first five individuals at the first locus.

<<nancy_indiv>>=
tab(nancycats)[1:5, 8:13]
@

When looking at this data set, recall how a \texttt{genind} object is formatted.
You have a matrix representing counts of alleles. For diploids, if you see 1,
that means it is heterozygous at that allele, and a 2 means it's homozygous.
Here we see three heterozygotes and two individuals with missing data (indicated
by NA). Let's look at what happens when we exclude loci and genotypes with
\textgreater 5\% missing data).

<<missingno_exclude>>=
nanloci <-  missingno(nancycats, "loci")
nangeno <-  missingno(nancycats, "geno")
tab(nanloci)[1:5, 8:13]
@

Notice how we now see columns named 
\Sexpr{na <- alleles(nancycats)[[2]]; paste(locNames(nancycats)[2], na[1:2], sep = ".", collapse = " and ")}. 
This is
showing us another locus because we have removed the first. Recall from the
summary table that the first locus had 16 alleles, and the second had 11. Now
that we've removed loci containing missing data, all others have shifted over.\\
Let's look at the loci names and number of individuals.

<<missingno_loci>>=
nInd(nanloci)     # Individuals
locNames(nanloci) # Names of the loci
@

You can see that the number of individuals stayed the same but the loci ``fca8",
``fca45", and ``fca96" were removed.\\

Let's look at what happened when we removed individuals.
<<missingno_geno>>=
tab(nangeno)[1:5, 8:13]
nInd(nangeno)     # Individuals
locNames(nangeno) # Names of the loci
@

We can see here that the number of individuals decreased, yet we have the same
number of loci. Notice how the frequency matrix changes in both scenarios? In
the scenario with ``loci", we removed several columns of the data set, and so
with our sub-setting, we see alleles from the second locus. In the scenario with
``geno", we removed several rows of the data set so we see other individuals in
our sub-setting.


% Let's first replace it by zero and mean, respectively.

% <<missingno_replace>>=
% nanzero <- missingno(nancycats, type = "zero")
% nanmean <- missingno(nancycats, type = "mean")
% nanzero$tab[1:5, 8:13]
% nanmean$tab[1:5, 8:13]
% is.genind(nanmean)
% @

% You notice how the values of NA changed, yet the basic structure stayed the
% same. 
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Extract populations \{Divide (populations) and conquer (your analysis)\}}
\label{data.manip:divide}

\tab\tab This \poppr{} function \texttt{popsub} makes subsetting \texttt{genind} or
genlight objects by population easier:

\subsubsection{Function: popsub}
\label{data.manip:divide:popsub}

\tab\tab The command \texttt{popsub} is powerful in that it allows you to choose
exactly what populations you choose to include or exclude from your analyses. As
with many R functions, you can also use this within a function to avoid
creating a new variable to keep track of.

\tline{}
\begin{quote}
Default Command:
<<popsub_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "popsub"
print_command(funk)
@

\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{sublist -} vector of populations or integers representing
  the populations in your data set you wish to \textbf{retain}. For example:
  \texttt{sublist = c("pop\_z", "pop\_y")} or \texttt{sublist = 1:2}.
  \item \texttt{blacklist -} vector of populations or integers representing
  the populations in your data set you wish to \textbf{exclude}. This can take the same
  type of arguments as sublist, and can be used in conjunction with sublist for
  when you want a range of populations, but know that there is one in there that
  you do not want to analyze. For example: \texttt{sublist = 1:15, blacklist =
  "pop\_x"}. One very useful thing about the blacklist is that it allows the
  user to be extremely paranoid about the data. You can set the blacklist to
  contain populations that are not even in your data set and it will still work!
  \item \texttt{mat -} (see section \seclink{mlg}{Multilocus Genotype
  Analysis} for more information) A matrix produced from
  the \cmdlink{mlg:table:mlg.table}{mlg.table} function. This overrides the
  \textit{pop} argument and subsets this table instead.
\end{itemize}
\bline{}

To demonstrate this tool, we'll use the H3N2 virus data set provided in 
\adegenet{}. It contains a data frame in the ``other'' slot called ``x'' that
contains information about the year of epidemic, country, etc.

<<load_H3N2>>=
data("H3N2", package = "adegenet")
strata(H3N2) <- data.frame(other(H3N2)$x)
H3N2
@

We will demonstrate the \texttt{popsub} functionality by setting the population
factor to ``country''. Note, in this section, I am naming the variables staring
with ``v'' indicating ``virus''.

<<popsub_sublist>>=
setPop(H3N2) <- ~country
popNames(H3N2) # Only two countries from North America.
v_na <- popsub(H3N2, sublist = c("USA", "Canada"))
popNames(v_na)
@

\noindent
If we want to see the population size, we can use the \adegenet{} function
\texttt{nInd()}:

<<popsub_sizes>>=
c(NorthAmerica = nInd(v_na), Total = nInd(H3N2))
@

\noindent
You can see that the population factors are correct and that the size of the
data set is considerably smaller. Let's see the data set without the North
American countries.

<<popsub_blacklist>>=
v_na_minus <- popsub(H3N2, blacklist = c("USA", "Canada"))
popNames(v_na_minus)
@

\noindent
Let's make sure that the number of individuals in both data sets is equal to
the number of individuals in our original data set:
<<length_test>>=
(nInd(v_na_minus) + nInd(v_na)) == nInd(H3N2)
@

Now we have data sets with and without North America. Let's try something a bit
more challenging. Let's say that we want the first 10 populations in
alphabetical order, but we know that we still don't want any countries in North
America. We can easily do this by using the \textit{base} function
\texttt{sort}.
<<popsub_combine>>=
vsort <- sort(popNames(H3N2))[1:10]
vsort
valph <- popsub(H3N2, sublist = vsort, blacklist = c("USA", "Canada"))
popNames(valph)
@

\noindent
And that, is how you subset your data with poppr!
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Clone-censor data sets \{Attack of the clone correction\}}
\label{data.manip:cc}

\tab\tab Clone correction refers to the ability of keeping one observation of
each MLG in a given population (or sub-population). Clone correcting can be
hazardous if its done by hand (even on small data sets) and it requires a
defined population hierarchy to get relevant results. \Poppr{} has a clone
correcting function that that will correct down to the lowest level of any
defined population hierarchy. Note that clone correction in \poppr{} is
sensitive to missing data, as it treats all missing data as a single extra
allele.

This function will create new data sets, but it is also utilized by the functions
 \texttt{poppr} and \texttt{poppr.amova} natively.

\subsubsection{Function: clonecorrect}
\label{data.manip:cc:clonecorrect}

\tab\tab This function will return a clone corrected data set corrected for the
lowest population level. Population levels are specified with the \texttt{hier}
flag. You can choose to combine the population hierarchy to analyze at the
lowest population level by choosing \texttt{combine = TRUE}.

\tline{}
\begin{quote}
Default Command:
<<clonecorrect_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "clonecorrect"
print_command(funk)
@
\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genclone} object with a defined hierarchy or a
   \texttt{genind} object that has a population hierarchy data frame in the
   \texttt{@other} slot. Note, the \texttt{genind} object does not necessarily
   require a population factor to begin with.
  \item \texttt{strata -} A hierarchical formula (eg. \texttt{$\sim$Pop/Subpop}),
  representing the hierarchical levels in your data.
  \item \texttt{combine -} Do you want to combine the population hierarchy? If
   it's set to \texttt{FALSE} (default), you will be returned an object with the
   top most hierarchical level as a population factor unless the \textbf{keep}
   argument is defined. If set to \texttt{TRUE}, the hierarchy will be returned
   combined.
  \item \texttt{keep -} This flag is to be used if you set \texttt{combine =
   FALSE}. This will tell clone correct to return a specific combination of your
   hierarchy defined as integers. For example, imagine a hierarchy that needs to
   be clone corrected at three levels:
   \textit{Population} by \textit{Year} by \textit{Month}. If you wanted to only
   run an analysis on the \textit{Population} level, you would set \texttt{keep
   = 1} since \textit{Population} is the first level of the hierarchy. On the
   other hand, if you wanted to run analysis on \textit{Year} by \textit{Month},
   you would set
   \texttt{keep = 2:3} since those are the second and third levels of the
   hierarchy.
\end{itemize}
\bline{}

Let's look at ways to clone-correct our data. We'll look at our \textit{A.
euteichies} data that we used in the \seclink{intro:qstart}{quickstart} since
that data set is known to include clonal populations \citep{Grunwald:2006}. Try
playing around with the data and see what different combinations of the
\texttt{hier}, and \texttt{keep} flags produce. Below, I will give three
examples of clone corrections at the sample level with respect to field, at the
field level, and finally, at the level of the entire data set.

First, we will examine the original data set.
<<clonecorrect>>=
data(Aeut)
strata(Aeut) <- data.frame(other(Aeut)$population_hierarchy[-1])
Aeut
@

When you read in data with \cmdlink{intro:import:read.genalex}{read.genalex},
the default is to represent it in a \texttt{genclone} object. Since the
\texttt{clonecorrect} function works on multilocus genotype definitions, It's
more efficient to convert it to a \texttt{genclone} object first. We will also rename the
strata to ``field'' and ``sample'' to make the biological relevance of the data
clearer.

<<clonecorrect_genclone>>=
aphan <- as.genclone(Aeut)
nameStrata(Aeut) <- ~field/sample
@

\noindent
Now we correct by sample with respect to field and keep the field as the
population.

<<clonecorrect2>>=
clonecorrect(aphan,  strata = ~Pop/Subpop)
# Your turn: Use the same stratification and use combine = TRUE and then
# keep = 1:2. Is there any difference?
@
\noindent
Correcting by field. Notice how the number of MLG is much closer to our census.
<<clonecorrect3>>=
clonecorrect(aphan, strata = ~Pop)
@
\noindent
Correcting over whole data set. Our MLG is equal to our census.
<<clonecorrectx>>=
clonecorrect(aphan, strata = NA)
@

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Permutations and bootstrap resampling \{every day I'm shuffling (data sets)\}}
\label{data.manip:shuffle}

\tab\tab A common null hypothesis for populations with mixed reproductive modes
is panmixia, or to put it simply: lots of sex. \Poppr{} randomly shuffles data
sets in order to calculate P-values for the index of association ($I_A$ and
$\bar{r} _d$) \citep{Agapow:2001} using 4 different methods:

% latex table generated in R 3.1.0 by xtable 1.7-3 package
% Fri May  2 23:17:17 2014
\begin{table}[ht]
\centering
\begin{tabular}{rll}
  \hline
method & strategy & units sampled \\
  \hline
1 & permutation & alleles \\
  2 & simulation & alleles \\
  3 & simulation & alleles \\
  4 & permutation & genotypes \\
   \hline
\end{tabular}
\end{table}

These methods are detailed below. We will create a dummy data set to be shuffled
by each example below. Let's assume a single diploid locus with four alleles (1,
2, 3, 4) with the frequencies of 0.1, 0.2, 0.3, and 0.4, respectively:

% latex table generated in R 3.0.3 by xtable 1.7-3 package
% Sun Mar 23 11:52:35 2014
\begin{table}[h!]
\centering
\begin{tabular}{lc}
          \hline
            & A1/A2 \\
          \hline
          1 & 4/4 \\
          2 & 4/1 \\
          3 & 4/3 \\
          4 & 2/2 \\
          5 & 3/3 \\
           \hline
        \end{tabular}
        \caption{Original}
        \label{tab:original}
\end{table}
\noindent
The 4 methods are detailed below.

\tline{}
\subsubsection{Function: shufflepop}
\label{data.manip:shuffle:shufflepop}
\begin{quote}
Default Command:
<<shufflepop_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "shufflepop"
print_command(funk)
@
% \texttt{shufflepop(pop, method = 1)}
\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{method -} a number indicating the method of sampling you wish to
  use. The following methods are available for use:
  \begin{enumerate}
    \item \textbf{Permute Alleles (default)} This is a sampling scheme that will \textbf{permute alleles within the locus.}
% <<shuffle_mat, echo=FALSE>>=
% exmat <- matrix(c(4,4,
%          4,1,
%          4,3,
%          2,2,
%          3,3), 5, byrow=TRUE)
% exmat
% @

The example above might become tables \ref{tab:permsinglebest} and \ref{tab:permtwobest}.
\begin{table}[h!]
\centering
\makebox[0pt][c]{\parbox{\textwidth}{%
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
            & A1/A2 \\
          \hline
          1 & 3/4 \\
          2 & 2/3 \\
          3 & 4/4 \\
          4 & 2/1 \\
          5 & 3/4 \\
           \hline
        \end{tabular}
        \caption{Permute 1}
        \label{tab:permsinglebest}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\
          \hline
        1 & 1/3 \\
          2 & 2/4 \\
          3 & 3/4 \\
          4 & 4/3 \\
          5 & 4/2 \\
           \hline
        \end{tabular}
        \caption{Permute 2}
        \label{tab:permtwobest}
    \end{minipage}
}}
\end{table}

As you can see, The heterozygosity has changed, yet the allelic frequencies
remain the same. Overall this would show you what would happen if
the sample you had underwent panmixis within this sample itself.
    \item \textbf{Parametric Bootstrap} The previous scheme reshuffled the
    observed sample, but the parametric bootstrap \textbf{draws samples from a
    multinomial distribution using the observed allele frequencies as weights.}
    Tables \ref{tab:param1} and \ref{tab:param2} are examples of what I mean.
% <<param_boot, echo=FALSE>>=
% set.seed(1001)
% cat("First Sample")
% matrix(sample(1:4, 10, prob=c(0.1,0.2,0.3,0.4), replace=TRUE), 5, byrow=T)
% cat("Second Sample")
% matrix(sample(1:4, 10, prob=c(0.1,0.2,0.3,0.4), replace=TRUE), 5, byrow=T)
% @

\begin{table}[h!]
\centering
\makebox[0pt][c]{\parbox{\textwidth}{%
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\
          \hline
        1 & 1/3 \\
          2 & 3/3 \\
          3 & 3/2 \\
          4 & 4/4 \\
          5 & 4/2 \\
           \hline
        \end{tabular}
        \caption{Parametric 1}
        \label{tab:param1}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\
          \hline
        1 & 3/4 \\
          2 & 2/3 \\
          3 & 4/2 \\
          4 & 4/4 \\
          5 & 4/2 \\
           \hline
        \end{tabular}
        \caption{Parametric 2}
        \label{tab:param2}
    \end{minipage}
}}
\end{table}

Notice how the heterozygosity has changed along with the allelic frequencies.
The frequencies for alleles 3 and 4 have switched in the first data set, and
we've lost allele 1 in the second data set purely by chance! This type of
sampling scheme attempts to show you what the true population would look like if
it were panmictic and your original sample gave you a basis for estimating
expected allele frequencies. Since estimates are made from the observed allele
frequencies, small samples will produce skewed results.
    \item \textbf{Non-Parametric Bootstrap} The third method is sampling with
    replacement, again \textbf{drawing from a multinomial distribution, but with no
    assumption about the allele frequencies} (tables \ref{tab:nonparam1} and \ref{tab:nonparam2}).
% <<boot, echo=FALSE>>=
% set.seed(1001)
% matrix(sample(1:4, 10, prob=rep(1, 4), replace=TRUE), 5, byrow=T)
% @

% latex table generated in R 3.0.3 by xtable 1.7-3 package
% Sun Mar 23 11:57:06 2014

\begin{table}[h!]
\centering
\makebox[0pt][c]{\parbox{\textwidth}{%
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\
          \hline
        1 & 1/3 \\
          2 & 3/3 \\
          3 & 3/1 \\
          4 & 2/2 \\
          5 & 3/1 \\
           \hline
        \end{tabular}
        \caption{Non-parametric 1}
        \label{tab:nonparam1}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\
          \hline
        1 & 1/3 \\
          2 & 3/1 \\
          3 & 2/3 \\
          4 & 2/1 \\
          5 & 4/3 \\
           \hline
        \end{tabular}
        \caption{Non-parametric 2}
        \label{tab:nonparam2}
    \end{minipage}
}}
\end{table}

Again, heterozygosity and allele frequencies are not maintained, but now all of
the alleles have a 1 in 4 chance of being chosen.
    \item \textbf{Multilocus permutation} This is called Multilocus permutation
    because it does the same thing as the permutation analysis in the program
    \textit{multilocus} by Paul Agapow and Austin Burt \citep{Agapow:2001}. This
    will shuffle the genotypes at each locus. Using our example above, tables
    \ref{tab:singlebest} and \ref{tab:twobest}
    are shuffled with method 4.
% <<multilocus_shuffle,echo=FALSE>>=
% set.seed(1001)
% exmat[sample(1:5), ]
% @

\begin{table}[h!]
\centering
\makebox[0pt][c]{\parbox{\textwidth}{%
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\
          \hline
        1 & 3/3 \\
          2 & 4/1 \\
          3 & 2/2 \\
          4 & 4/4 \\
          5 & 4/3 \\
           \hline
        \end{tabular}
        \caption{ML 1}
        \label{tab:singlebest}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\
          \hline
        1 & 4/4 \\
          2 & 2/2 \\
          3 & 3/3 \\
          4 & 4/3 \\
          5 & 4/1 \\
           \hline
        \end{tabular}
        \caption{ML 2}
        \label{tab:twobest}
    \end{minipage}
}}
\end{table}

  Note that you have the same genotypes after shuffling, so at each locus, you
  will maintain the same allelic frequencies and heterozygosity. So, in this
  sample, you will only see a homozygote with allele 2. This also ensures that
  the P-values associated with $I_A$ and $\bar{r} _d$ are exactly the same. This
  method \textbf{assumes that alleles are not independently assorting within
  individuals.} This strategy is \textbf{useful if you suspect the population is
  inbreeding} (Jerome Goudet, personal communication).
  \end{enumerate}

\end{itemize}

\bline{}

These shuffling schemes have been implemented for the index of association, but
there may be other summary statistics you can use \texttt{shufflepop} for. All
you have to do is use the function \texttt{replicate}. Let's use
average Bruvo's distance with the first population of the
data set \texttt{nancycats} as an example:
<<shuffle_bd>>=
data(nancycats)
nan1 <- popsub(nancycats, 1)
reps <- rep(2, 9) # Assuming dinucleotide repeats.
observed <- mean(bruvo.dist(nan1, replen = reps))
observed
@
<<shuffle_bd_replicate_dummy, eval=FALSE>>=
set.seed(9999)
bd.test <- replicate(999, mean(bruvo.dist(shufflepop(nan1, method = 2), replen = reps)))
@
<<shuffle_bd_replicate, echo = FALSE>>=
load("nancybruvo.rda")
@
You could use this method to replicate the resampling 999 times and then create
a histogram to visualize a distribution of what would happen under different
assumptions of panmixia.

<<bd_histogram, resolution = 300>>=
hist(bd.test, xlab = "Bruvo's Distance", main = "Average Bruvo's distance over 999 randomizations")
abline(v = observed, col = "red")
legend('topleft', legend="observed", col="red", lty = 1)
@

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Removing uninformative loci \{Cut It Out!\}}
\label{data.manip:informloci}
\tab\tab Phylogenetically uninformative loci are those that have only one
sample differentiating from the rest. This can lead to biased results when
using multilocus analyses such as the index of association \citep{Brown:1980,Smith:1993}.
These nuisance loci can be removed with the following function.
\subsubsection{Function: informloci}
\label{data.manip:informloci:informloci}

\tline{}
\begin{quote}
Default Command:
<<informloci_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "informloci"
print_command(funk)
@
% \texttt{informloci(pop, cutoff = 2/nInd(pop), quiet = FALSE)}
\end{quote}
  \begin{itemize}
    \item \texttt{pop -} a \texttt{genind} object.
    \item \texttt{cutoff -} this represents the minimum fraction of individuals
    needed for a locus to be considered informative. The default is set to $2/n$
    with $n$ being the number of individuals in the data set (represented by the
    \adegenet{} function \texttt{nInd}). Essentially, this means that any locus
    with fewer than 2 observations differing will be removed. The user can also
    specify a fraction of observations for the cutoff (eg. 0.05).
    \item \texttt{MAF -} (Minor Allele Frequency), This defaults to 0.01
    indicating that loci that contain one allele representing 1 - MAF of the
    data will be removed.
    \item \texttt{quiet -} if \texttt{TRUE}, nothing will be printed to the
    screen, if \texttt{FALSE} (default), the cutoff value in percentage and
    number of individuals will be printed as well as the names of the
    uninfomrative loci found.
  \end{itemize}
\bline{}

Here's a quick example using the H3N2 virus SNP data set from section
\seclink{data.manip:divide}{on subsetting your data}. We will only retain loci
that have a minor allele frequency of $\geq 5\%$

<<inform.H3N2.1, eval = FALSE>>=
H.five <- informloci(H3N2, cutoff = 0.05)
@
<<inform.H3N2.2, echo = FALSE, message = TRUE>>=
#res <- c(157,177,233,243,262,267,280,303,313,327,357,382,384,399,412,418,424,425,429,433,451,470,529,546,555,557,564,576,592,595,597,602,612,627,642,647,648,654,658,663,667,681,717,806,824,837,882)
# cat("cutoff value: 5 percent ( 95 individuals ).\n","47 uninfomative loci found:", res, fill = 80)
msg <- readLines("msg.txt")
for (i in msg) message(i)
@
Now what happens when you have all informative loci. We'll use the nancycats
data set, which has microsatellite loci. It is important to note that this is
searching for loci with a specified genotype frequency as fixed heterozygous
sites are also uninformative:
<<inform.nancy, message = TRUE>>=
data(nancycats)
naninform <- informloci(nancycats, cutoff = 0.05)
@

%=============================================================================%
%=============================================================================%
%
%
%
%=============================================================================%
%=============================================================================%
\section{Multilocus Genotype Analysis}
\label{mlg}

\tab\tab In populations with mixed sexual and clonal reproduction, it common to
have multiple samples from the same population that have the same set of alleles
at all loci. Here, we introduce tools for tracking MLGs within and across
populations in \seclink{intro:genind}{genind} objects from the \adegenet{}
package. We will be using the H3N2 data set containing
SNP data from isolates of the H3N2 virus from 2002 to 2006. Note that genclone
objects are optimal for these analyses. For a more in-depth document on methods
for multilocus genotypes in \poppr{}, see the ``Multilocus Genotype Analysis'' 
vignette by typing 
<<eval = FALSE>>=
vignette("mlg", package = "poppr")
@
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{How many multilocus genotypes are in our data set? \{Just a peek\}}
\label{mlg:mlg}
\tab\tab Counting the number of MLGs in a population is the
first step for these analyses as they allow us to see how many clones
exist. With the \seclink{intro:genclone}{genclone} object, This information is
already displayed when we view the object.
<<view_mlg>>=
H3N2
@
\noindent
If we need to store the number of MLGs as a variable, we can simply run the
\texttt{mlg} command.
<<mlg_genind>>=
H3N2_mlg <- mlg(H3N2)
H3N2_mlg
@
\label{mlg:mlg:mlg}

Since the number of individuals exceeds the number of multilocus
genotypes, we conclude that this data set contains clones. Let's examine what populations these clones belong to.
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{MLGs across populations \{clone-ing around\}}
\label{mlg:cross}

\tab\tab Since you have the ability to define hierarchical levels of your
data set freely, it is quite possible to see some of the same MLGs across
different populations. Tracking them by hand can be a nightmare with large data
sets. Luckily, \texttt{mlg.crosspop} has you covered in that regard.
\subsubsection{Function: mlg.crosspop}
\label{mlg:cross:mlg.crosspop}

\tab\tab Analyze the MLGs that cross populations within your data set. This has
three output modes. The default one gives a list of MLGs, and for each MLG, it
gives a named numeric vector indicating the abundance of that MLG in each
population. Alternate outputs are described with \texttt{indexreturn} and
\texttt{df}.

\tline{}
\begin{quote}
Default Command:
<<mlg.crosspop_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "mlg.crosspop"
print_command(funk)
@
\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{sublist -} Populations to include (Defaults to ``ALL'').
  see \cmdlink{data.manip:divide:popsub}{popsub.}
  \item \texttt{blacklist -} Populations to exclude. see \cmdlink{data.manip:divide:popsub}{popsub.}
  \item \texttt{mlgsub -} see \cmdlink{mlg:table:mlg.table}{mlg.table.} Only
  analyze specified MLGs. The vector for this flag can be produced by this
  function as you will see later in this vignette.
  \item \texttt{indexreturn -} return a vector of indices of MLGs. (You can
  use these in the \texttt{mlgsub} flag, or you can use them to subset the
  columns of an MLG table).
  \item \texttt{df -} return a data frame containing the MLGs, the populations
  they cross, and the number of copies you find in each population. This is
  useful for making graphs in \textit{ggplot2}.
  \item \texttt{quiet -} \texttt{TRUE} or \texttt{FALSE}. Should the
  populations be printed to screen as they are processed? (will print nothing
  if \texttt{indexreturn} is \texttt{TRUE})
\end{itemize}

\bline{}

We can see what MLGs cross different populations and then give a
vector that shows how many populations each one of those MLGs crosses.
<<crosspop, eval=FALSE>>=
setPop(H3N2) <- ~country
v.dup <- mlg.crosspop(H3N2, quiet=TRUE)
@
Here is a snippet of what the output looks like when \texttt{quiet} is
\texttt{FALSE}. It will print out the MLG name, the total number of individuals
that make up that MLG, and the populations where that MLG can be found.
<<crosspopout, echo=FALSE>>=
setPop(H3N2) <- ~country
v.dup <- structure(list(MLG.3 = structure(c(4L, 8L), .Names = c("USA",
"Denmark")), MLG.9 = structure(c(1L, 13L, 1L, 1L), .Names = c("Japan",
"USA", "Finland", "Denmark")), MLG.31 = structure(c(2L, 7L), .Names = c("Japan",
"Canada")), MLG.75 = structure(c(2L, 8L, 2L, 1L, 6L, 2L, 1L,
1L), .Names = c("Japan", "USA", "Finland", "Norway", "Denmark",
"Austria", "Russia", "Ireland")), MLG.80 = structure(c(1L, 1L
), .Names = c("USA", "Denmark")), MLG.86 = structure(3:4, .Names = c("Denmark",
"Austria")), MLG.95 = structure(c(1L, 1L), .Names = c("USA",
"Bangladesh")), MLG.97 = structure(c(1L, 5L, 1L, 1L), .Names = c("USA",
"Austria", "Bangladesh", "Romania")), MLG.104 = structure(1:2, .Names = c("USA",
"France")), MLG.110 = structure(c(2L, 3L, 11L), .Names = c("Japan",
"USA", "China"))), .Names = c("MLG.3", "MLG.9", "MLG.31", "MLG.75",
"MLG.80", "MLG.86", "MLG.95", "MLG.97", "MLG.104", "MLG.110"))
printthings <- function(ind, x){
  cat(paste0(names(x)[ind], ":"),
      paste0("(", sum(x[[ind]])," inds)"),
      names(x[[ind]]),
      "\n")
}
invisible(lapply(1:10, printthings, v.dup))
@
The output of this function is a list of MLGs, each containing a vector
indicating the number of copies in each population. We'll count the number of
populations each MLG crosses using the function \texttt{sapply} to loop over
the data with the function \texttt{length}.
<<crosspop2>>=
head(v.dup)
v.num <- sapply(v.dup, length) # count the number of populations each MLG crosses.
head(v.num)
@
%\newpage
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Producing MLG tables and graphs \{bringing something to the table\}}
\label{mlg:table}

We can also create a table of MLGs per population as well as bar graphs to give
us a visual representation of the data. This is achieved through the function
\texttt{mlg.table}
\subsubsection{Function: mlg.table}
\label{mlg:table:mlg.table}

\tab\tab This function will produce a matrix containing counts of MLGs (columns)
per population (rows). If there are not populations defined in your data set, a
vector will be produced instead.

\tline{}
\begin{quote}
Default Command:
<<mlg.table_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "mlg.table"
print_command(funk)
@
% \texttt{mlg.table(pop, sublist = "ALL", blacklist = NULL, mlgsub = NULL, bar = TRUE, total = FALSE, quiet = FALSE)}
\end{quote}
  \begin{itemize}
    \item \texttt{pop -} a \texttt{genind} object.
    \item \texttt{sublist -} Populations to include (Defaults to ``ALL'').
    see \cmdlink{data.manip:divide:popsub}{popsub.}
    \item \texttt{blacklist -} Populations to exclude.
    see \cmdlink{data.manip:divide:popsub}{popsub.}
    \item \texttt{mlgsub -} a vector containing the indices of MLGs you wish to
    subset your table with.
    \item \texttt{plot -} \texttt{TRUE} or \texttt{FALSE}. If  \texttt{TRUE}, a
    bar plot will be printed for each population with more than one individual.
    \item \texttt{total -} When set to \texttt{TRUE}, the pooled data set will
    be added to the table. Defaults to \texttt{FALSE}.
    \item \texttt{quiet -} Defaults to \texttt{FALSE}: population names will
    be printed to the console as they are processed.
  \end{itemize}
\bline{}

<<mlgbar, eval = FALSE>>=
v.tab <- mlg.table(H3N2, plot = TRUE)
v.tab[1:10, 1:10] # Showing the first 10 columns and rows of the table.
@
<<mlgbarshow, echo = FALSE>>=
v.tab <- mlg.table(H3N2, plot = FALSE)
v.tab[1:10, 1:10] # Showing the first 10 columns and rows of the table.
@
\begin{figure}[h!]
  \centering
  \caption{\footnotesize An example of a bar-chart produced by
  \texttt{mlg.table}. Note that this data set would produce several such
  charts but only the chart for Norway is shown here.}
  \label{nortable}
<<mlgbarplot, results = 'hide', out.width = "0.8\\linewidth">>=
mlg.table(H3N2, sublist = "Norway", plot = TRUE)
@
\end{figure}
\newpage

The MLG table is not limited to use with \poppr{}. In fact, one of the main
advantages of \texttt{mlg.table} is that it allows easy access to diversity
functions present in the package \textit{vegan} \citep{vegan}. One example is to
create a rarefaction curve for each population in your data set giving the
number of expected MLGs for a given sample size. For more information, type
\texttt{help("diversity", package="vegan")} in your R console.

For the sake of this example, instead of drawing a curve for each of the 37
countries represented in this sample, let's set the hierarchical level to year.
<<mlgrare1_dummy, eval = FALSE>>=
setPop(H3N2) <- ~year
summary(H3N2) # Check the data to make sure it's correct.
@
<<mlgrare1, echo = FALSE>>=
setPop(H3N2) <- ~year
res <- c("", " # Total number of genotypes:  1903 ", "", " # Population sample sizes:  ",
         "2002 2003 2004 2005 2006 ", " 158  415  399  469  462 ", "",
         " # Number of alleles per locus:  ", "  6  17  39  42  45  51  60  72  73  90 108 123 129 134 145 148 149 157 168 171 177 225 ",
         "  3   3   4   2   4   2   3   2   4   3   4   2   4   3   2   2   3   3   2   2   3   3 ",
         "233 243 247 262 267 280 303 313 317 327 334 345 351 357 376 382 384 391 396 399 412 418 ",
         "  3   2   2   2   2   2   2   2   2   2   2   4   4   3   3   3   4   2   2   2   4   3 ",
         "424 425 429 430 433 434 435 451 463 464 468 470 476 483 490 517 529 546 555 557 561 562 ",
         "  2   3   4   2   3   2   3   2   2   2   4   2   2   2   2   2   2   2   4   4   4   3 ",
         "564 566 576 577 578 582 592 594 595 597 600 602 604 612 627 642 647 648 654 658 663 664 ",
         "  3   2   3   4   3   2   3   3   3   3   2   3   2   4   2   3   2   2   3   3   3   3 ",
         "666 667 673 674 676 679 681 685 717 763 806 807 824 837 882 897 906 910 915 929 933 936 ",
         "  2   2   2   2   3   2   3   2   3   2   3   2   3   3   2   2   2   3   2   2   2   3 ",
         "939 940 957 961 962 963 966 967 969 973 975 977 978 979 980 ",
         "  3   3   2   2   3   3   3   3   4   2   3   3   4   3   2 ",
         "", " # Number of alleles per population:  ", "2002 2003 2004 2005 2006 ",
         " 203  255  232  262  240 ", "", " # Percentage of missing data:  ",
         "[1] 2.363426", "", " # Observed heterozygosity:  ", "[1] 0",
         "", " # Expected heterozygosity:  ", "[1] 0")
cat(res, sep = "\n")
@
<<mlgrare2, eval=FALSE, tidy=FALSE>>=
library("vegan")
H.year <- mlg.table(H3N2, plot = FALSE)
rarecurve(H.year, ylab="Number of expected MLGs", sample=min(rowSums(H.year)),
          border = NA, fill = NA, font = 2, cex = 1, col = "blue")
@
\begin{figure}[h!]
  \centering
  \caption{\footnotesize An example of a rarefaction curve produced using a MLG table.}
  \label{rarecurve}
<<mlgrareplot, echo=FALSE, results='hide'>>=
# library("vegan")
H.year <- mlg.table(H3N2, plot = FALSE)
vegan::rarecurve(H.year, ylab="Number of expected MLGs", sample=min(rowSums(H.year)), border = NA, fill = NA, font = 2, cex = 1, col = "blue")
@
\end{figure}
\newpage

The minimum value from the \textit{base} function \texttt{rowSums()} of the
table represents the minimum common sample size of all populations defined in
the table. Setting the ``sample" flag draws the horizontal and vertical lines
you see on the graph. The intersections of these lines correspond to the numbers
you would find if you ran the function \texttt{poppr} on this data
set (under the column ``\texttt{eMLG}").

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Combining MLG functions \{getting into the mix\}}
\label{mlg:mix}

\tab\tab Alone, the different functionalities are neat. Combined, we can create
interesting data sets. Let's say we wanted to know which MLGs were duplicated
across the regions of the United Kingdom, Germany, Netherlands, and Norway. All
we have to do is use the \texttt{sublist} flag in the function:
<<subcross>>=
setPop(H3N2) <- ~country
UGNN.list <- c("United Kingdom", "Germany", "Netherlands", "Norway")
UGNN <- mlg.crosspop(H3N2, sublist=UGNN.list, indexreturn=TRUE)
@
OK, the output tells us that there are three MLGs that are crossing between
these populations, but we do not know how many are in each. We can easily find
that out if we subset our original table, \texttt{v.tab}.

<<subtable>>=
UGNN # Note that we have three numbers here. This will index the columns for us.
UGNN.list # And let's not forget that we have the population names.
v.tab[UGNN.list, UGNN]
@

Now we can see that Norway has a higher incidence of nearly all of these MLGs.
We can investigate the incidence of these MLGs throughout our data set. One
thing that the \seclink{intro:genclone}{genclone} object keeps track of is a
single vector defining the unique multilocus genotypes within the data. These
are represented as integers and can be accessed with \texttt{mlg.vector}. This
is useful for finding MLGs that correspond to certain individuals or
populations. Let's use \texttt{mlg.vector} to find individuals corresponding to
the MLGs. First we'll investigate what the output of this function looks like.

<<mlg.vector_first>>=
v.vec <- mlg.vector(H3N2)
str(v.vec) # Analyze the structure.
@
\noindent
The integers produced are the MLG assigment of each individual in the same order
as the data set. This means that the first two individuals have the exact same
set of alleles at each locus, so they have the same MLG: \Sexpr{v.vec[1]}. If
we look at the number of unique integers in the vector, it corresponds to the
number of observed multilocus genotypes:
<<mlg.vector_second>>=
length(unique(v.vec)) # count the number of MLGs
H3N2 # equal to the first number in this output.
@
\label{mlg:mix:mlg.vector}
\noindent
We will take \texttt{UGNN} (MLGs crossing UK, Germany, Netherlands, and Norway)
and compare its elements to the MLG vector (\texttt{v.vec}) to see where else
they occur.

<<mlg.vector_match>>=
UGNN # Show what we are looking for
UGNN_match <- v.vec %in% UGNN
table(UGNN_match) # How many individuals matched to those three MLGs?
@
\noindent
22 individuals matched to those three MLGs. We can use this vector to show us
the 22 individuals.

<<mlg.vector_inds>>=
indNames(H3N2)[UGNN_match]
@

Note that there is an alternative way to list individuals matching specific MLGs
using the function \texttt{mlg.id}. This function will return a list where each
element represents a unique MLG. You can use this data to find out which
individuals correspond to specific MLGs. Each element in the list is named with
the MLG, but the index does not necessarily match up, so it is important to
convert your query MLGs to strings:
\label{mlg:mix:mlg.id}
<<mlg.id>>=
H3N2.id <- mlg.id(H3N2)
H3N2.id[as.character(UGNN)]
@


We can also use the vector of MLGs to
subset \cmdlink{mlg:table:mlg.table}{mlg.table} with the \texttt{mlgsub} flag.
<<mlgsub_flag, eval=FALSE>>=
mlg.table(H3N2, mlgsub = UGNN)
@
\noindent
That showed us exactly which populations these three MLGs came from in our data
set.
\begin{figure}[h!]
  \centering
  \caption{\footnotesize All populations that contain these MLGs}
  \label{nortable2}
<<mlgsub_flagshow, results='hide', echo=FALSE, out.width = "0.8\\linewidth">>=
mlg.table(H3N2, mlgsub = UGNN)
@
\end{figure}
\newpage

%=============================================================================%
%=============================================================================%
%
%
%
%=============================================================================%
%=============================================================================%
\renewcommand\thesection{\Alph{section}}
\setcounter{section}{0}

\section{Appendix}
\label{appendix}

\subsection{Manipulating Graphics}

\Poppr{} utilizes \textit{ggplot2} to produce many of its graphs. One advantage
it gives the user is the ability to manipulate these graphs. With base R graphs,
the only manipulation that can be performed is by adding elements to the graph.
It is a static image. The ggplot graphs are actually represented as objects in
your R environment. We can use the function \texttt{last\_plot()} from
\textit{ggplot2} to be able to grab the plot that was plotted last in our
window. Let's illustrate this using a MLG bar graph from the Aeut data set.

<<Aeut_MLG_Aeut, fig.width = 7, fig.height = 3, out.width = "0.8\\linewidth">>=
library("poppr")
library("ggplot2")
data(Aeut)
Aeut.tab <- mlg.table(Aeut)
p <- last_plot()
@

We've captured our plot using \texttt{last\_plot()} and now we can manipulate
it. One common need is to change the title. We can easily do that with the
function \texttt{ggtitle()}. Let's say we wanted to label it
``\textit{Aphanomyces euteiches} multilocus genotype distribution''. We would
use \texttt{ggtitle("Aphanomyces euteiches multilocus genotype distribution")}.
Unfortunately, we need italics for a latin binomial. One way to acheive this is
by using the \texttt{expression()} function and declaring which text needs to be
italicized.

<<Aeut_MLG_title, fig.width = 7, fig.height = 3, out.width = "0.8\\linewidth">>=
myTitle <- expression(paste(italic("Aphanomyces euteiches"), " multilocus genotype distribution"))
(pt <- p +
   ggtitle(myTitle) +
   xlab("Multilocus genotype")) # We can label the x axis, too
@

Let's say we wanted to remove the grey background. We could use the
\texttt{theme()} function to do this, or we could use a theme already
implemented in ggplot2 called \texttt{theme\_bw()}.


<<Aeut_MLG_theme, fig.width = 7, fig.height = 3, out.width = "0.8\\linewidth">>=
(ptt <- pt + theme_bw())
@

Uh-oh. The x axis labels are now horizontal when they should be vertical. Since
it's the overall distribution we're interested in, we don't really need them
anyways. We can remove them with \texttt{axis.text.x} and \texttt{axis.ticks.x}.

<<Aeut_MLG_theme_axis, fig.width = 7, fig.height = 3, out.width = "0.8\\linewidth">>=
(ptta <- ptt + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()))
@

And, if for some bizzarre reason, you liked the color gradient in \poppr{}
version 1, you can get that back by adding the \textit{fill} aesthetic:

<<Aeut_silly, fig.width = 7, fig.height = 3, out.width = "0.8\\linewidth">>=
(ptttaf <- ptta + aes(fill = count))
@

This allows you to produce publication quality graphs directly in R. Please see
Hadley Wickham's \textit{ggplot2} package for more details \citep{ggplot2}. Note
that if you don't like using \textit{ggplot2}, you can access the data in the
ggplot2 object and plot the data yourself:

<<Aeut_MLG_data>>=
head(p$data)
@


%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Exporting Graphics}
\label{appendix:graphics}
\tab\tab R has the ability to produce nice graphics from most any type of data,
but to get these graphics into a report, presentation, or manuscript can be a
bit challenging. It's no secret that the R Documentation pages are a little
difficult to interpret, so I will give the reader here a short example on how to
export graphics from R. Note that any code here that will produce images will
also be present in other places in this vignette. The default installation of
the R GUI is quite minimal, and for an easy way to manage your plots and code, I
strongly encourage the user to use Rstudio \url{http://www.rstudio.com/}.

\subsubsection{Basics}
\label{appendix:graphics:basics}
\tab\tab Before you export graphics, you have to ask yourself what they will be
used for. If you want to use the graphic for a website, you might want to opt
for a low-resolution image so that it can load quickly. With printing, you'll
want to make sure that you have a scalable or at least a very high resolution
image. Here, I will give some general guidelines for graphics (note that these
are merely suggestions, not defined rules).
\begin{itemize}
  \item \textbf{What you see is not always what you get} I have often seen
  presentations where the colors were too light or posters with painfully
  pixellated graphs. Think about what you are going to be using a graphic for
  and how it will appear to the intended audience given the media type.
  \item \textbf{$\geq$ 300 dpi unless its for a web page} For any sort of
  printed material that requires a raster based image, 300dpi (dots per inch) is
  the absolute minimum resolution you should use. For simple black and white
  line images, 1200dpi is better. This will leave you with crisp, professional
  looking images.
  \item \textbf{If possible, save to SVG, then rasterize} Raster images (bmp,
  png, jpg, etc...) are based off of the number of pixels or dots per inch it
  takes to render the image. This means that the raster image is more or less a
  very fine mosaic. Vector images (SVG) are built upon several interconnected
  polygons, arcs, and lines that scale relative to one another to create your
  graphic. With vector graphics, you can produce a plot and scale it to the size
  of a building if you wanted to. When you save to an SVG file first, you can
  also manipulate it in programs such as Adobe Illustrator or Inkscape.
  \item \textbf{Before saving, make sure the units and dimensions are correct}
  Unless you really wanted to save a graph that's over 6 feet wide.
\end{itemize}

\subsubsection{Image Editors}
\label{appendix:graphics:editors}
\tab\tab Often times, fine details such as labels on networks need to be tweaked
by hand. Luckily, there are a wide variety of programs that can help you do
that. Here is a short list of image editors (both free and for a price) that you
can use to edit your graphics.
\begin{itemize}
  \item Bitmap based editors (for jpeg, bmp, png, etc...)
  \begin{quote}
  \begin{itemize}
    \item[ \scshape The GIMP ] Free, cross-platform. \url{http://www.gimp.org}
    \item[ \scshape Paint.net ] Free, Windows only.
    \url{http://www.getpaint.net}
    \item[ \scshape Adobe Photoshop ] Pricey, Windows and Mac.
    \url{http://www.adobe.com/products/photoshop.html}
  \end{itemize}
  \end{quote}
  \item Scalable Vector Graphics based editors (for svg, pdf)
  \begin{quote}
  \begin{itemize}
    \item[ \scshape Inkscape ] Free, cross-platform \url{http://inkscape.org}
    \item[ \scshape Adobe Illustrator ] Pricey, Windows and Mac.
    \url{http://www.adobe.com/products/illustrator.html}
  \end{itemize}
  \end{quote}
\end{itemize}

\subsubsection{Exporting ggplot2 graphics}
\label{appendix:graphics:ggplot2}
\tab\tab \textit{ggplot2} is a fantastic package that \poppr{} uses to produce
graphs for the \texttt{mlg.table}, \texttt{poppr}, and \texttt{ia} functions.
Saving a plot with \textit{ggplot2} is performed with one command after your
plot has rendered:
<<ggsave1, eval=FALSE>>=
data(nancycats) # Load the data set.
poppr(nancycats, sample=999) # Produce a single plot.
ggsave("nancycats.pdf")
@
Note that you can name the file anything, and \texttt{ggsave} will save it in
that format for you. The details are in the documentation and you can access it
by typing \texttt{help("ggsave")} in your R console. The important things to
note are that you can set a \texttt{width}, \texttt{height}, and \texttt{unit}.
The only downside to this function is that you can only save one plot at a time.
If you want to be able to save multiple plots, read on to the next section.

\subsubsection{Exporting any graphics}
\label{appendix:graphics:export}
\tab\tab Some of the functions that \poppr{} offers will give you multiple
plots, and if you want to save them all, using \texttt{ggsave} will require a
lot of tedious typing and clicking. Luckily, R has Functions that will save any
plot you generate in nearly any image format you want. You can save in raster
images such as png, bpm, and jpeg. You can also save in vector based images such
as svg, pdf, and postscript. The important thing to remember is that when you
are saving in a raster format, the default units of measurement are ``pixels",
but you can change that by specifying your unit of choice and a resolution.

For raster images and svg files, you can only save your plots in multiple files,
but pdf and postscript plots can be saved in one file as multiple pages. All of
these functions have the same basic form. You call the function to specify the
file type you want (eg. \texttt{pdf("myfile.pdf")}), create any graphs that you
want to create, and then make sure to close the session with the function
\texttt{dev.off()}. Let's give an example saving to pdf and png files.

<<png_save, eval=FALSE>>=
data(nancycats)
####
png("nancy_pair%02d.png", width = 14, height = 14, units = "in", res = 300)
poppairs <- lapply(seppop(nancycats), pair.ia, limits = c(-0.25, 1))
dev.off()
####
@

Since this data set is made up of 30 populations with more than 1 individual,
this will save 30 files to your working directory named
``nancy\_pair\_barchart01.png...nancy\_pair\_barchart30.png". The way R knows
how to number these files is because of the \texttt{\%02d} part of the command.
That's telling R to use a number that is two digits long in place of that
expression. All of these files will be 14x14" and will have a resolution of 300
dots per inch. If you wanted to do the same thing, but place them all in one
file, you should use the pdf option.

<<pdf_save, eval=FALSE>>=
pdf("nancy_pair.png", width = 14, height = 14, compress = FALSE)
poppairs <- lapply(seppop(nancycats), pair.ia, limits = c(-0.25, 1))
dev.off()
@

Remember, it is important not to forget to type \texttt{dev.off()} when you are
done making graphs. Note that I did not have to specify a resolution for this
image since it is based off of vector graphics.

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%

\bibliographystyle{authordate1}
\bibliography{the_bibliography}
\end{document}
